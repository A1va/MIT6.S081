## 如果

一些指针常见的习惯用法尤其值得记住：

- 如果`int *p = (int*)100`，则 `(int)p + 1`和`(int)(p + 1)` 的结果是不同的：第一个是`101`，第二个是`104`。
  在向指针添加整数时(如第二种情况)，该整数被隐式地**乘以**指针指向的对象的大小。
- `p[i]`的定义为与`*(p+i)`相同，指的是`p`指向的内存中的第`i`个对象。当对象大于一个字节时，面的加法规则有助于这此定义。
- `&p[i]`与`(p+i)`相同，在`p`指向的内存中产生第`i`个对象的地址。

```c
#include <stdio.h>
#include <stdlib.h>

void
f(void)
{
    // %p就是取值的，以16进制输出
    int a[4];
    int *b = malloc(16);
    int *c;
    int i;

    // a是数组地址(基于该函数的栈区，基础偏移为0):0061FEF8
    // b是动态申请的内存空间的地址(基于该函数的堆，基础偏移由操作系统决定):00B51AC0
    // c是 局部指针变量的地址 : but why 0061FF50 > a > d
    // &i是int型局部变量的地址，(基于该函数的栈区，基础偏移为0):0061FEF4
    // a > d是因为 a先创建，先被push进栈区
    printf("1: a = %p, b = %p, c = %p, i = %p\n", a, b, c, &i);

    c = a;
    for (i = 0; i < 4; i++)
	    a[i] = 100 + i;
    c[0] = 200;
    printf("2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n",
	   a[0], a[1], a[2], a[3]);

    c[1] = 300;
    *(c + 2) = 301;
    3[c] = 302;
    printf("3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n",
	   a[0], a[1], a[2], a[3]);

    c = c + 1;          // +1指向了下一个元素
    *c = 400;
    printf("4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n",
	   a[0], a[1], a[2], a[3]);

    c = (int *) ((char *) c + 1);           // int:4 Byte, char: 1 Byte
    /**
     * 400:0001 1001 0000B
     * 301:0001 0010 1101B
     * 500:0001 1111 0100B
     * 指向对象类型的指针可能会转换为指向不同对象类型的指针
     * 如果生成的指针没有正确地与所引用类型对齐，则出现**未定义的行为**
     * 将500(0001 1111 0100B) -> 400:(0001)
     * after:
     * a[1]:400 -> 128144:  0001 1111 0100 1001 0000B
     * a[2]:301 -> 256:     0001 0000 0000B
     */ 
    *c = 500;
    printf("5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n",
	   a[0], a[1], a[2], a[3]);

    b = (int *) a + 1;
    c = (int *) ((char *) a + 1);           
    // addr:b = a+4, c = a+1
    // a = 0061FEF8, b = 0061FEFC, c = 0061FEF9
    printf("6: a = %p, b = %p, c = %p\n", a, b, c);

    /**
     * 如果int *p = (int*)100，则 (int)p + 1和(int)(p + 1) 是不同的数字：第一个是101，第二个是104。在第二种情况下，当将整数添加到指针时，该整数会隐式乘以指针指向的对象的大小。
     * p[i]定义为与相同*(p+i)，指的是p指向的内存中的第i个对象。当对象大于一个字节时，以上加法规则有助于此定义。
     * &p[i]与(p+i)相同，在p指向的内存中产生第i个对象的地址。
     */ 
}

int
main(int ac, char **av)
{
    f();
    return 0;
}
```

